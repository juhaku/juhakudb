apply plugin: 'com.android.library'
apply plugin: 'net.researchgate.release'
apply plugin: 'maven'
apply plugin: 'signing'

repositories {
    mavenCentral()
    mavenLocal()
    maven {
        url repositoryURL
        credentials {
            username = gradleArtifactoryUser
            password = gradleArtifactoryPassword
        }
    }
}

android {
    compileSdkVersion 25
    buildToolsVersion '25.0.3'

    defaultConfig {
        minSdkVersion 16
        targetSdkVersion 25
    }
    signingConfigs {
        release {
            storeFile file("keys/juhakussh.keystore")
            storePassword keyStoreKey
            keyPassword keyStoreKey
        }
    }
    buildTypes {
        debug {
            debuggable true;
        }
        release {
            signingConfig signingConfigs.release
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
    testOptions {
        unitTests.returnDefaultValues = true
    }
    lintOptions {
        abortOnError false
    }
}

dependencies {
    //    deployerJars 'org.apache.maven.wagon:wagon-ssh:2.2'
    //compile fileTree(dir: 'libs', include: ['*.jar'])
    testCompile 'junit:junit:4.12'
    compile 'com.android.support:appcompat-v7:25.2.0'
    //    compile 'javax.persistence:persistence-api:1.0.2'
    compile 'org.hibernate.javax.persistence:hibernate-jpa-2.1-api:1.0.0.Final'
}

release {
    tagTemplate = "${rootProject.name}-$version".replace("-SNAPSHOT", "")
    git {
        requireBranch = 'master'
    }
}

task sourceJar(type: Jar) {
    from android.sourceSets.main.java.srcDirs
    classifier 'sources'
}

task javadoc(type: Javadoc) {
    source = android.sourceSets.main.java.srcDirs
    failOnError false
    destinationDir = file('../javadoc')
}

task javadocJar(type: Jar) {
    from javadoc
    classifier 'javadoc'
}

configurations {
    archives {
        extendsFrom configurations.default
    }
    source {
        sourceJar
    }
    javadoc {
        javadocJar
    }
}

artifacts {
    archives sourceJar, javadocJar
}

signing {
    sign configurations.archives
}

uploadArchives {
    repositories.mavenDeployer {
        beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }

        repository(url: repositoryURL) { //repositoryURL
            authentication(userName: gradleArtifactoryUser, password: gradleArtifactoryPassword) //gradleArtifactoryUser, gradleArtifactoryPassword
        }

        pom.project {
            name rootProject.name
            groupId 'juhaku-android'
            artifactId 'juhaku-db'
            packaging 'aar'
            version = project.version
            description 'Database ORM library for Android projects'
            url repositoryURL

            scm {
                connection repositoryURL
                developerConnection repositoryURL
                url repositoryURL
            }

            licenses {
                license {
                    name 'The MIT License'
                    url 'https://opensource.org/licenses/MIT'
                }
            }

            developers {
                developer {
                    id 'juhaku'
                    name 'Juha Kukkonen'
                }
            }
        }
    }
}

task uploadCentral(type: Upload) {
    configuration = configurations.archives
    repositories.mavenDeployer {

        beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }

        repository(url: ossrhRepositoryURL) {
            authentication(userName: ossrhUsername, password: ossrhPassword)
        }

        pom.project {
            name rootProject.name
            groupId 'io.github.juhaku'
            artifactId 'juhaku-db'
            packaging 'aar'
            version = project.version.replace("-SNAPSHOT", "")
            description 'Database ORM library for Android projects'
            url 'https://github.com/juhaku/juhakudb'

            scm {
                connection repositoryURL
                developerConnection repositoryURL
                url repositoryURL
            }

            licenses {
                license {
                    name 'The MIT License'
                    url 'https://opensource.org/licenses/MIT'
                }
            }

            developers {
                developer {
                    id 'juhaku'
                    name 'Juha Kukkonen'
                }
            }
        }
    }
}
uploadCentral.description = 'Upload archives to maven central'

task updatePomVersion << {
    release.tagTemplate = "${rootProject.name}-$version"
    uploadArchives.repositories.mavenDeployer.pom.version = version
    uploadCentral.repositories.mavenDeployer.pom.version = version
}

task formatReleaseVersion << {
    formatSinceJavaDocVersion(1)
}

task formatBuildVersion << {
    formatSinceJavaDocVersion(0)
    addLicence()
}

task revert(type: Exec) {
    // linux version
    commandLine revertCommand
}
revert.description = 'Rollback commit on release failure'

task('uploadLocal', type: Upload.class) {
    repositories.mavenInstaller {
        configuration = configurations.archives
        pom {
            project {
                name rootProject.name
                groupId 'juhaku-android'
                artifactId 'juhaku-db'
                packaging 'aar'
                version = project.version
                description 'Database ORM library for Android projects'
                url repositoryURL

                scm {
                    connection repositoryURL
                    developerConnection repositoryURL
                    url repositoryURL
                }

                licenses {
                    license {
                        name 'The MIT License'
                        url 'https://opensource.org/licenses/MIT'
                    }
                }

                developers {
                    developer {
                        id 'juhaku'
                        name 'Juha Kukkonen'
                    }
                }
            }
        }.withXml {
            def dependenciesNode = asNode().appendNode('dependencies')

            configurations.compile.allDependencies.each { dependency ->

                def dependencyNode = dependenciesNode.appendNode('dependency')
                dependencyNode.appendNode('groupId', dependency.group)
                dependencyNode.appendNode('artifactId', dependency.name)
                dependencyNode.appendNode('version', dependency.version)
            }
        }
    }
}
uploadLocal.dependsOn build
uploadLocal.description = 'Uploads archives to local maven repository'

preBuild.dependsOn formatBuildVersion
checkSnapshotDependencies.dependsOn formatReleaseVersion

createReleaseTag.dependsOn uploadArchives
preTagCommit.dependsOn updatePomVersion

createReleaseTag.dependsOn uploadCentral
uploadCentral.shouldRunAfter uploadArchives

def released = false
gradle.taskGraph.beforeTask { Task task ->
    if (task.name == 'release' && !released) {
        released = true
        project.ext['rollbackVersion'] = project.version
    }
}

gradle.taskGraph.afterTask { Task task, TaskState state ->
    if (state.failure && released) {
        revert();
    }
}

void restoreRollbackVersion() {
    if (project.ext.has('rollbackVersion')) {
        version = project.ext['rollbackVersion']
        ant.propertyfile(file: 'gradle.properties') {
            entry(key: 'version', value: project.ext['rollbackVersion'])
        }
    }
}

void revert() {
    restoreRollbackVersion()
    formatSinceJavaDocVersion(2)
    revert.execute()
}

void formatSinceJavaDocVersion(int state) {
    String source = android.sourceSets.main.java.srcDirs.collect {it}.toList().get(0)
    FileTree tree = fileTree(new File(source)) {
        include {
            '**/*.java'
        }
    }
    tree.each {File file ->
        String content = file.text
        String newContent
        if (state == 1) { // release
            newContent = content.replaceAll("@since \\d+\\.\\d+\\.\\d+-SNAPSHOT", "@since " + project.version)
        } else if (state == 2) { // rollback
            String rollback = project.version as String
            rollback = rollback.replace("-SNAPSHOT", "")
            newContent = content.replaceAll("@since $rollback(?!-SNAPSHOT)", "@since $project.version")
        } else { // default build
            newContent = content.replaceAll("@since((?! )|(?! \\d+\\.\\d+\\.\\d+(-SNAPSHOT)?))", "@since $project.version")
//            newContent = content.replaceAll("\\{version\\}", project.version)
        }
        if (content != newContent) {
            file.write(newContent)
        }
    }
}

void addLicence() {
    String licence = new File("LICENSE").text
    licence = "/**\n$licence*/\n"

    String source = android.sourceSets.main.java.srcDirs.collect { it }.toList().get(0)
    FileTree tree = fileTree(new File(source)) {
        include {
            '**/*.java'
        }
    }

    tree.each { File file ->
        String content = file.text
        String newContent

        if (!content.startsWith(licence)) {
            newContent = "$licence$content"
        }

        if (newContent != null && content != newContent) {
            file.write(newContent)
        }
    }
}